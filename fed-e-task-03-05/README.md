### 1、Vue 3.0 性能提升主要是通过哪几方面体现的？
1.响应式系统的实现原理做了优化；
2.编译优化，diff策略更优更快；
3.打包体积
<!-- 首先，Vue 3中使用Proxy对象实现响应式系统，Proxy本身的性能就优于Vue 2中使用的defineProperty，Proxy对象可以拦截属性的增删查改操作，不需要初始化的时候遍历所有属性，在多层嵌套属性中，只有使用到某个属性时才递归处理下一级属性。

其次，Vue 3在编译时的处理比Vue 2更优。Vue 3标记和提升了静态根节点，diff时只需要对比动态节点，需要对比的节点比2中更少，且通过Patch flag标记了动态节点的响应式类型，只需要对比对应的属性。3中还缓存了事件处理函数，只有调用时才会判断更新对应代码。

Vue 3也优化了项目打包体积，移除了一些不常用的API，支持Tree-shaking，按需引入模块。 -->

### 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？
Composition Api的开发方式基于函数，同一功能的代码在一个函数中，而Options Api可能需要分到data，methods，各个生命周期函数中。Composition Api代码组织更清晰，功能复用更方便。

### 3、Proxy 相对于 Object.defineProperty 有哪些优点？
Proxy可以拦截对象属性的访问，修改，删除等操作，这样不需要提前遍历就可以监控对象所有属性，并且还支持监控属性的删除，数组的length属性变化和动态新增的属性，这些是defineProperty做不到的。

### 4、Vue 3.0 在编译方面有哪些优化？
Vue 3标记和提升了静态根节点，diff时只需要对比动态节点，需要对比的节点比2中更少，且通过Patch flag标记了动态节点的响应式类型，只需要对比对应的属性。3中还缓存了事件处理函数，只有调用时才会判断更新对应代码。

### 5、Vue.js 3.0 响应式系统的实现原理？
通过Proxy拦截对对象的操作，通过Reflect实现对应操作的默认行为。

在访问属性时，递归遍历该属性下级属性并为该属性收集依赖。在修改或删除属性时判断新旧值，若不同则触发该属性所有依赖的更新。

在收集依赖时，为所有对象建立一个Map，每个对象对应多个属性，每个属性对应多个依赖函数，通过这种结构维护响应式对象属性与依赖的关系。