# 简答题
### 第一题
执行结果为 10  
因为var声明的变量i没有块作用域的概念，相当于全局变量，当循环执行结束后，i的值为最终的10。  
当运行 `a[6]()` 时，打印出的i为10。
### 第二题
执行报错  
因为打印tmp所在块作用域中tmp由let声明，let声明变量没有变量提升的特性，执行时会返回引用异常的错误。
### 第三题
找出数组arr中最小值  
`Math.min(...arr)`
### 第四题
详细说明var,let,const三种声明变量的方式之间的具体差别  
var是ES6之前的声明变量的方式，没有块作用域的概念，只有全局作用域与函数作用域的概念；  
let 与 const 声明的变量在所在块作用域内生效；
var声明变量存在变量声明提升的特性，let 与 const 必须先声明后引用；
let 与 var 用来定义变量， const 用来定义常量，不可修改；
let 与 const不可重复定义，会有语法报错。
### 第五题
执行结果为 20  
setTimeout回调函数使用的是箭头函数，箭头函数中this指向的就是箭头函数所在上下文，即obj对象，所以打印的是obj对象的a属性值。
### 第六题
简述Symbol类型的用途  
Symbol可以定义一个独一无二的值，主要用于定义对象的属性名，防止属性名冲突导致属性覆盖的问题。  
Symbol定义的属性也非常适合作为对象的私有属性。
### 第七题
浅拷贝 深拷贝  
浅拷贝是复制了对象所在内存地址的指针，深拷贝复制的是内存地址中的具体数据；  
浅拷贝复制的对象修改，会同时修改被复制对象，深拷贝复制的对象修改不会改变被复制对象，两者的值存在不同的内存中。
### 第八题
JS是单线程语言，实现异步编程的方式主要是采取回调函数的方法，主线程代码依次压入调用栈执行，当遇到需要异步处理的代码时，由对应的API处理，处理结束后放入消息队列等待主线程执行结束后依次执行。  
Event Loop监听调用栈与消息队列，当调用栈中的事件处理结束时，将消息队列的第一条压入调用栈继续执行。  
消息队列中的每一条回调都是一个宏任务，新的宏任务会重新添加到消息队列的末尾等待执行；微任务作为宏任务的“附带任务”，不必重新进入队列，可在当前宏任务执行结束后直接执行。引入微任务的概念主要是为了提升整体的执行效率。绝大部分异步回调都是宏任务，Promise，MutationObserver和node中的process.nextTick是微任务。  
### 第九题
    Promise.resolve()
    .then(() => {
        return 'hello ';
    })
    .then((value) => {
        return value + 'lagou ';
    })
    .then((value) => {
        console.log(value + 'I love you')
    })
### 第十题
TypeScript是JavaScript的超集，在JavaScript的基础上新增了类型系统，并且兼容了ES6及以后的最新规范。
TypeScript支持JavaScript的编写方式，最终也会编译成JavaScript。
### 第十一题
TypeScript的优点包括支持代码中变量，参数和属性值的类型声明，避免类型异常；支持ECMAScript新特性的兼容；同时兼容性很高，适合大型，长周期项目开发使用。  
TypeScript的缺点在于新概念与特性的学习成本，以及项目初期增加开发成本，不太适合短期项目开发。